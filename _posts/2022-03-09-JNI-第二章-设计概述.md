---
title: JNI 第二章 设计概述
date: 2022-03-09 10:31
tags:
    - JNI

---

## JNI 接口方法和指针

本地代码通过调用 JNI 方法访问 JVM 功能，JNI 方法通过*接口指针* 使用。接口指针是指向指针的指针，它指向一个指针数组，数组中的各个元素都指向一个接口方法。各个接口方法都位于数组中预定义好的偏移位置。

JNI 接口是像 C++ 的虚函数表或者 COM 接口一样组织的。使用接口表而不是硬链接的函数条目（hard-wired function entries）的好处是使得 JNI 的命名空间和本地代码隔离开来。虚拟机可以方便的提供多个版本的 JNI 函数表，例如：

- 一个执行彻底的非法参数检查，适用于调试。
- 另一个执行 JNI 规范要求的最小量检查，因此更高效。

JNI 接口指针只在当前线程有效。因此本地方法不应该将接口指针从一个线程传到另一个线程。实现 JNI 的虚拟机会在 JNI 接口指针指向的区域分配和存储线程的本地数据。

本地方法接收 JNI 接口指针作为参数。当从同一个 Java 线程多次调用本地方法时，虚拟机会保证传递相同的接口指针给本地方法。当同一个本地方法从不同的 Java 线程调用时，会接收到不同的接口指针。

## 编译、加载和链接本地方法

因为 JVM 是多线程的，因此本地库应该也使用支持多线程的编译器进行编译和链接。

本地方法通过 *System.loadLibrary* 方法加载：

```kotlin
// NativeUtil.kt
object NativeUtil {
    init {
        System.loadLibrary("jnicourse")
    }

    @JvmStatic
    external fun stringFromJNI(): String

}
```

*System.loadLibrary* 的参数是程序员任意选择的库名称，系统会根据特定平台以一定的标准，将库名称转换为本地库名称。例如，Solaris 系统会将 jnicourse 转为 jincourse.so，Win32 系统会将 jnicouser 转为 jnicourse.dll。

只要是使用同一个类加载器加载的类，其所包含的所有本地方法都可以用同一个库存储。虚拟机内部有一个包含各个类加载器已加载的本地方法的列表，供应商应尽量选择不易冲突的本地库名称。

本地库可以和虚拟机静态链接，本地库和虚拟机镜像的结合方式取决于具体实现。*System.loadLibrary* 或等效的 API 调用成功本地库才能认为已经被加载完成。

当且仅当导出（export）了名为 JNI_OnLoad_X 函数，其镜像已经整合到虚拟机的库（X）才会被定义为静态链接。

如果一个静态链接库（X）同时导出了 JNI_OnLoad_X 和 JNI_OnLoad 两个函数，后者将被忽略。

如果一个静态库（X）同时同时导出了 JNI_OnUnLoad_X 和 JNI_OnUnLoad 两个函数，后者将被忽略。

静态链接库 X，在 System.loadLibrary("X") 或等价的 API 被调用之前，JNI_OnLoad_X 将被调用，并且是与 JNI_OnLoad 相同的参数和返回值。

已经静态链接了的库将禁止同名的库被动态加载。

如果库（X）有导出 JNI_OnUnLoad_X 方法，则当类加载器中包含的静态库（X）被垃圾回收后，虚拟机将调用该方法。

开发者还可以调用 JNI 函数 RegisterNatives() 来注册与类相关的本地方法，特别是静态链接的方法。

#### 解析本地方法名

动态链接器是根据条目的名字来进行解析的，一个本地方法名称由以下部分组合而来：

- 前缀 Java_
- 变换后的全类名
- 下划线分隔符“_”
- 变换后的方法名
- 对于重载的本地方法，参数签名后面要跟两个下划线“__”

虚拟机会在已加载的本地库中检查出名称匹配的方法。虚拟机首先检查不含参数签名的短名称，再检查包含参数签名的长名称。当一个本地方法被另一个本地方法重载时，程序员需要使用长名称。但是，本地方法与非本地方法同名却不是问题，因为非本地方法（Java 方法）不驻留在本地库中。

```kotlin
// NativeUtil.kt
object NativeUtil {
    init {
        System.loadLibrary("jnicourse")
    }

    @JvmStatic
    external fun foo(name: String)

    fun foo(age: Int) {

    }
}
```

我们应用一种简单的名称修改方案来确保所有 Unicode 字符都能转换成有效的 C 函数名。用下划线字符代替全限定类名中的斜杠，因此名称或类型描述符不会以数字开头，使用 _0,...,_9 作为转义序列。

| 转义序列 | 表示                                                   |
| -------- | ------------------------------------------------------ |
| _0XXXX   | Unicode 字符 XXXX，小写用于表示非 ASCII Unicode 字符。 |
| _1       | "_" 字符                                               |
| _2       | 签名中的 ";" 字符                                      |
| _3       | 签名中的 "[" 字符                                      |

本地方法和接口 API 都遵循给定平台上的标准库调用规则。例如，Unix 系统使用 C 调用规则，Win32 系统使用 __stdcall。

#### 本地方法参数

本地方法的第一个参数是 JNI 接口指针，类型是 *JNIEnv* 。第二个参数取决于该本地方法是静态的还是非静态的，非静态方法的第二个参数是其所属对象的引用，静态方法的第二个参数是其所属类（Java class）的引用。

其余参数对应于常规的 Java 方法参数。本地方法可以通过返回值将结果传递回调用处。

下面实例分别使用 C 和 C++ 实现本地方法。

**本地方法**

```kotlin
package com.huoergai.jnicourse

/**
 * D&T: 2022/3/10 下午3:35
 * Des:
 */
object NativeUtil {
    init {
        System.loadLibrary("jnicourse")
    }

    @JvmStatic
    external fun bar(age: Int, name: String): Double
}
```

**C 实现**

```c
#include <jni.h>

jdouble Java_com_huoergai_jnicourse_NativeUtil_bar(JNIEnv* env,jclass clazz,jint age,jstring name){
    const char *cname = (*env)->GetStringUTFChars(env, name, 0);
    ...
    (*env)->ReleaseStringUTFChars(env, name, cname);
    
    ...
}
```

**C++ 实现**

```c++
extern "C" jdouble
Java_com_huoergai_jnicourse_NativeUtil_bar(JNIEnv *env, jclass clazz, jint age, jstring name) {
    const char *cname = env->GetStringUTFChars(name, 0);
    ...
    env->ReleaseStringUTFChars(name, cname);
    ...
}
```

使用 C++，可以一定程度上简化代码，例如省略了接口指针参数和额外的间接层级。但是，其底层机制与 C 完全相同。在 C++ 中，JNI 方法定义为和 C 等价的内联成员方法。

## 引用 Java 对象

像整型、字符等基本类型在 Java 和本地代码之间是通过复制传递的。Java 对象则是通过引用传递。虚拟机必须跟踪被传递到本地代码的对象，以免它们被垃圾回收器释放。因此，当本地代码不再需要这些对象时，必须通过一种方式通知虚拟机。并且垃圾回收器必须能够移动被本地代码引用到的对象。

#### 全局引用和局部引用

JNI 把本地代码中引用的对象分为两类：本地引用和全局引用。本地引用在本地方法调用期间可用，在本地方法返回后自动释放。全局引用直到明确的释放前都可用。

对象作为局部引用传递给本地方法。所有 JNI 方法返回的 Java 对象都是局部引用。JNI 允许使用局部引用来创建全局引用。JNI 方法可以接收局部引用和全局引用的 Java 对象。本地方法可以返回局部引用和全局引用作为结果给虚拟机。

大多数情况下，开发者应该依靠虚拟机在本地方法返回后释放所有局部引用。也有部分情况需要显示的释放局部引用：

- 本地方法访问一个较大的 Java 对象，并创建了该对象的局部引用。然后本地方法在返回调用前执行额外的计算，这个较大对象的本地引用会阻止其被垃圾回收，即使在余下的计算中这个对象已经不再被需要了。
- 本地方法创建了大量的本地引用，尽管它们不是被同时用到。因为虚拟机需要一定空间来跟踪局部引用，创建太多的局部引用可能导致系统内存不足。例如，在一个本地方法中循环一个较大的对象数组，每次迭代的时候获取元素作为局部引用，并在元素上执行操作。每次迭代过后，数组元素的局部引用都不再需要。

JNI 允许在本地方法中的任意时刻手动删除本地引用。为保证手动的释放本地引用，JNI 方法不允许创建额外的本地引用，除非是作为返回结果的引用。

本地引用只在其创建的线程内有效，在本地代码中，不能在线程之间传递本地引用。

#### 实现局部引用

为实现局部引用，Java 虚拟机为每个从 Java 到 本地方法的转换控制创建了一个注册表。不可移动的本地引用对 Java 对象的映射，并阻止这些对象被垃圾回收。所有被传递给本地方法的 Java 对象（包括作为 JNI 调用结果返回的）都自动的加入到这个映射表中。在本地方法返回后，这个注册表会被删除，以致它里面所有的条目得以被垃圾回收。

可以使用包括表、链表、哈希表等不同方式实现注册表。尽管可以使用引用计数在注册表中避免重复实体，但是 JNI 实现不负责检测和折叠重复实体。

注意：通过保守地扫描本地栈来实现的本地引用是不可靠的，本地代码可能将本地引用存储在全局或者堆数据结构中。

## 访问 Java 对象

JNI 提供了一套丰富的全局和本地应用方位方法，意味着不管虚拟机内部如何表示 Java 对象，相同的本地方法实现都有效。这也是为什么 JNI 可以被各大虚拟机实现所支持的重要原因。

通过不透明的引用方式的访问方法比直接访问 C 数据结构的开销要高。大多数情况下，应该使用本地方法执行可以抵消接口开销的重要的任务。

#### 访问基本类型数组

这种开销对于像整型数组、字符串等包含大量基本数据类型的大型 Java 对象是不可接受的。（考虑到用于执行向量和举证计算的本地方法）在调用方法中迭代 Java 数组并获取每个元素是非常抵消的。

一种解决方案是引入 "pinning" 概念，本地方法请求虚拟机固定数组的内容，然后本地方法获得直接指向元素的指针。这种方式有两个前提：

- 垃圾回收器支持 pinning。
- 虚拟机必须将基本数据类型的数组分配在连续的内存中。尽管对于大多数基本数据类型的数组这是最自然的实现，但是 boolean 数组可以是压缩和非压缩两种实现方式。因此依赖 boolean 数组特定布局方式的本地代码将不可移植。

我们采用了一种能克服以上两个问题的折中方案。

首先，提供一组在 Java 数组片段和本地内存缓存之间复制基本数据类型数组中元素的方法。当本地方法只需要访问大型数组中的少量元素时使用这些方法。

其次，可以使用另一组方法获取一个 pinned-down 版本的数组元素。留意这些方法可能需要虚拟机执行内存分配和复制操作。实际这些方法是否复制数组取决于虚拟机的实现，如下：

- 如果垃圾回收器支持 pinning，并且数组的布局同本地方法期望的一直就不需要复制。
- 否则，数组就被复制到一个不可移动的内存块（例如，C 中的堆内存）并执行必要的格式转换，再返回副本的指针。

最后，接口提供方法来通知虚拟机本地代码不再需要访问这些数组元素。当这些方法被调用的时候，系统要么 unpin 该数组，要么调整原数组和它不可移动的副本，并释放该副本。

这种方式提供了灵活性。垃圾回收器算法可以对每个给定数组的复制或 pining 做出单独决定。例如，垃圾回收器可能会复制小型对象，但是 pin 大型对象。

JNI 实现必须确保多线程中的本地方法可以同时访问同一个数组，例如，JNI 可能需要为各个 pinned 数组维持一个的内部计数器，因此一个线程不能 unpin 一个被另一个线程 pined 的数组。注意，JNI 不必为本地方法独占地访问基本类型数组而锁定它。与此同时，在不同线程更新 Java 数组会导致不可预测的结果。

#### 访问字段和方法

JNI 允许本地代码访问 Java 对象的字段和调用其方法。JNI 通过名称、类型签名来辨识方法和字段。两步流程因素避免了从它们的名称、签名中定位字段和方法的开销。例如，为调用类 Foo 中的 bar 方法，本地代码首先获取到方法 ID：

```kotlin
// NativeLib.kt
class NativeLib {
    
    fun foo(): Double {
        return 0.0
    }

}
```

```c++
jmethodID mid = env->GetMethodID(clazz, "foo", "()D");
jdouble result = env->CallDoubleMethod(obj, mid);
```

本地代码可以重复使用方法 ID ，不用每次都花费查找方法的开销。

从类中派获取到的字段或方法 ID 不能阻止虚拟机卸载（unload）类。当类被卸载后，方法和字段 ID 就变得不可用了。因此本地方法必须确保以下两点：

- 保持对潜在类的实时引用。
- 如果要在超出的时间中使用这些方法或字段 ID，就重新获取 。

JNI 对字段和方法 ID 的内部实现没有任何限制。

## 报告编程错误

JNI 不会检查像传入空指针、非法参数类型这样的编程错误。非法参数类型还包括像使用普通的 Java 对象代替 Java 类对象的情况。JNI 基于以下原因不检查这些编程错误：

- 强制 JNI 方法检查所有可能的错误情况会降低普通正确本地代码的性能。
- 大多数情况下，没有足够多的运行时类型信息来做这种检查。

大多数 C 库函数都不防范编程错误。例如 *printf()* 函数接收了不可用的地址时，经常引起运行时错误，而不是返回一个错误码。强制 C 库函数检查所有可能的错误情况可能会导致重复的检查，用户代码里面检查一遍，在库里面再检查一遍。

编程人员不应该传递非法指针、错误类型的参数给 JNI 函数。这样做可能会导致任意后果，包括系统状态异常和虚拟机崩溃。

## Java 异常

JNI 允许本地方法处理任意的 Java 异常。本地代码还可以处理未处理的 Java 异常，剩余未处理的 Java 异常会回传到虚拟机。

#### 异常和错误码

部分 JNI 函数使用 Java 异常机制来报告错误情况。大部分情况下，JNI 函数通过返回错误码和抛出 Java 异常来报告错误情况。错误码通常是正常返回值范围外的一个特殊的返回值（例如 NULL）。因此编程人员可以：

- 通过快速的检查最后的 JNI 调用返回值来决定是否发生错误。
- 通过调用 *ExceptionOccurred()* 函数来获取包含更详细错误描述信息的异常对象。

以下两种情况下，需要检查异常，而不必首先检查错误码：

- JNI 函数调用了返回 Java 方法结果的 Java 方法。必须调用 *ExceptionOccurred()* 来检查 Java 方法执行期间可能发生的异常。
- 一些不返回错误码，但会抛出 ArrayIndexOutOfBoundsException 或 ArrayStoreException 的访问数组的 JNI 方法。

剩余的所有情况下，非错误的返回值就能保证没有异常抛出。

#### 异步异常

多线程情况下，当前线程以外的线程肯能抛出异步异常。直到以下情况，异步异常才会影响本地代码在当前线程的执行：

- 本地代码调用了可能发生同步异常的 JNI 函数。
- 本地代码使用 ExceptionOccurred() 明确地检查同步和异步异常。

注意，只有那些可能抛出同步异常的 JNI 函数才检查异步异常。

本地方法应该在必要的位置（例如没有其余异常检查的循环中）插入 ExceptionOccurred() 来确保当前线程能够在合理的时间内响应异步异常。

#### 异常处理

在本地代码中有两种处理异常的方式：

- 立即返回，导致在调用本地代码的 Java 代码位置抛出异常。
- 通过调用 ExceptionClear() 清除异常，并执行自己的异常处理代码。

在发生异常后，本地代码执行其它 JNI 调用前应该首先清除异常。当有未处理的异常时，可以安全调用的 JNI 函数有：

```java
ExceptionOccurred()
ExceptionDescribe()
ExceptionClear()
ExceptionCheck()
ReleaseStringChars()
ReleaseStringUTFChars()
ReleaseStringCritical()
Release<Type>ArrayElements()
ReleasePrimitiveArrayCritical()
DeleteLocalRef()
DeleteGlobalRef()
DeleteWeakGlobalRef()
MonitorExit()
PushLocalFrame()
PopLocalFrame()
```
